<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çŠ¬ã®é¼»ãƒ©ãƒ™ãƒªãƒ³ã‚°ç®¡ç†ãƒ„ãƒ¼ãƒ«</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

		.container {
			max-width: 1200px;
			margin: 0 auto;
			padding: 20px;
			padding-top: 80px; /* ãƒ˜ãƒƒãƒ€ãƒ¼åˆ†ã®ä½™ç™½ */
		}
		.header {
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			color: white;
			padding: 20px;
			border-radius: 10px;
			margin-bottom: 20px;
			text-align: center;
		}
		.header h1 {
			font-size: 2.5em;
			margin-bottom: 10px;
		}
		.header p {
			font-size: 1.1em;
			opacity: 0.9;
		}

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .image-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .control-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .image-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .image-display {
            max-width: 100%;
            max-height: 500px;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .image-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .image-info h3 {
            color: #495057;
            margin-bottom: 10px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .nav-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .nav-button:hover {
            background: #0056b3;
        }

        .nav-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .image-counter {
            font-weight: bold;
            font-size: 18px;
        }

        .label-section {
            margin-bottom: 20px;
        }

        .label-section h3 {
            margin-bottom: 15px;
            color: #495057;
        }

        .label-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .label-button {
            padding: 15px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            font-weight: bold;
        }

        .label-button:hover {
            border-color: #007bff;
            background: #f8f9fa;
        }

        .label-button.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .label-button.nose {
            border-color: #28a745;
        }

        .label-button.nose.active {
            background: #28a745;
            border-color: #28a745;
        }


        .sub-labels {
            margin-bottom: 20px;
        }

        .sub-label-group {
            margin-bottom: 15px;
        }

        .sub-label-group h4 {
            margin-bottom: 8px;
            color: #6c757d;
        }

        .sub-label-options {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .sub-label-option {
            padding: 5px 10px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .sub-label-option:hover {
            border-color: #007bff;
        }

        .sub-label-option.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .dataset-split {
            margin-bottom: 20px;
        }

        .split-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }

        .split-button {
            padding: 8px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .split-button:hover {
            border-color: #007bff;
        }

        .split-button.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .save-button {
            width: 100%;
            padding: 15px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 20px;
            transition: background-color 0.3s;
        }

        .save-button:hover {
            background: #218838;
        }

        .export-section {
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }

        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .export-button {
            padding: 10px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .export-button:hover {
            background: #5a6268;
        }

        .shortcuts {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .shortcut-key {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }

        .no-images {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    {% include 'header.html' with context %}
    <div class="container" style="padding-top:80px;">
        <div class="header">
            <h1>ğŸ• çŠ¬ã®é¼»ãƒ©ãƒ™ãƒªãƒ³ã‚°ç®¡ç†ãƒ„ãƒ¼ãƒ«</h1>
            <p>çŠ¬ã®é¡”ç”»åƒã‹ã‚‰é¼»ã®æœ‰ç„¡ã‚’åˆ¤å®šã—ã€æ©Ÿæ¢°å­¦ç¿’ç”¨ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’ä½œæˆã—ã¾ã™</p>
        </div>

        <div class="main-content">
            <div class="image-section">
                <div class="navigation">
                    <button class="nav-button" id="prevBtn" onclick="previousImage()">â† å‰ã®ç”»åƒ</button>
                    <div class="image-counter">
                        <span id="currentIndex">0</span> / <span id="totalImages">0</span>
                    </div>
                    <button class="nav-button" id="nextBtn" onclick="nextImage()">æ¬¡ã®ç”»åƒ â†’</button>
                </div>

                <div class="image-container" id="imageContainer" style="display: flex; align-items: center; gap: 32px; min-height: 500px;">
                    <div style="flex-shrink:0;">
                        <div class="loading">ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
                        <!-- ç”»åƒã¨canvasã‚’é‡ã­ã¦è¡¨ç¤ºã™ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼ -->
                        <div id="imageCanvasWrapper" style="position: relative; display: inline-block;">
                            <!-- ç”»åƒã¯JSã§æŒ¿å…¥ -->
                            <!-- canvasã¯ç”»åƒã¨åŒã˜ã‚µã‚¤ã‚ºãƒ»ä½ç½®ã§é‡ã­ã‚‹ -->
                            <canvas id="bboxCanvas" style="position: absolute; left: 0; top: 0; z-index: 2; display: none;"></canvas>
                        </div>
                        <div style="width:100%; display:flex; justify-content:center;">
                            <button id="openOriginalModalBtn" class="nav-button" style="margin-top: 16px; width: auto; min-width: 160px;">å…ƒç”»åƒã‚µã‚¤ã‚ºã§ç·¨é›†</button>
                        </div>
                    </div>
        <!-- å…ƒç”»åƒã‚µã‚¤ã‚ºç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="originalModal" style="display:none; position:fixed; z-index:10000; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.5); justify-content:center; align-items:center;">
            <div style="background:#fff; border-radius:12px; padding:24px; position:relative; max-width:98vw; max-height:98vh; overflow:auto;">
                <button id="closeOriginalModalBtn" style="position:absolute; right:12px; top:12px; font-size:20px; background:none; border:none; cursor:pointer;">Ã—</button>
                <div id="originalModalContent" style="display:flex; flex-direction:column; align-items:center;">
                    <!-- å…ƒç”»åƒã¨canvasã‚’ã“ã“ã«å‹•çš„ã«æŒ¿å…¥ -->
                </div>
                <div style="margin-top:16px; text-align:center;">
                    <button id="saveOriginalModalBtn" class="nav-button">ç·¨é›†å†…å®¹ã‚’ä¿å­˜</button>
                </div>
            </div>
        </div>
                    <div style="flex:1; display:flex; justify-content:center; align-items:center; min-width:0;">
                        <div id="croppedBoxWrapper" style="min-width:120px; max-width:400px; display:none; text-align:center; align-self:center; width:100%;">
                            <div style="font-size:13px;color:#888;margin-bottom:4px;">é¼»é ˜åŸŸãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</div>
                            <div style="display:flex;justify-content:center;align-items:center;">
                                <canvas id="croppedBoxCanvas" style="border:2px solid #aaa; border-radius:12px; background:#fff; max-width:100%; max-height:400px; display:block;"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="image-info" id="imageInfo" style="display: none;">
                    <h3>ç”»åƒæƒ…å ±</h3>
                    <div class="info-item">
                        <span>ãƒ•ã‚¡ã‚¤ãƒ«å:</span>
                        <span id="fileName">-</span>
                    </div>
                    <div class="info-item">
                        <span>ãƒ‘ã‚¹:</span>
                        <span id="filePath">-</span>
                    </div>
                    <div class="info-item">
                        <span>ç¾åœ¨ã®ãƒ©ãƒ™ãƒ«:</span>
                        <span id="currentLabel">æœªè¨­å®š</span>
                    </div>
                    <div class="info-item">
                        <span>BBox:</span>
                        <span id="bboxInfo">-</span>
                    </div>
                    <div class="info-item">
                        <span>ä½œæ¥­æ¸ˆã¿:</span>
                        <span id="isCompletedInfo">-</span>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <div class="label-section">
                    <h3>ãƒ¡ã‚¤ãƒ³ãƒ©ãƒ™ãƒ«</h3>
                    <div class="label-buttons">
                        <button class="label-button nose" onclick="setMainLabel('nose')">
                            ğŸ½ é¼»ã‚ã‚Š (1)
                        </button>
                    </div>
                </div>

                <div class="sub-labels">
                    <h3>ã‚µãƒ–ãƒ©ãƒ™ãƒ«</h3>
                    <div class="sub-label-group">
                        <h4>é¼»ã®å‘ã</h4>
                        <div class="sub-label-options">
                            <span class="sub-label-option" data-label="front" onclick="toggleSubLabel('front')">æ­£é¢ (F)</span>
                            <span class="sub-label-option" data-label="side" onclick="toggleSubLabel('side')">æ¨ªå‘ã (S)</span>
                            <span class="sub-label-option" data-label="tilted" onclick="toggleSubLabel('tilted')">æ–œã‚ (T)</span>
                        </div>
                    </div>
                    <div class="sub-label-group">
                        <h4>é®®æ˜åˆ¤å®š</h4>
                        <div class="sub-label-options">
                            <span class="sub-label-option" data-label="clear" onclick="toggleSubLabel('clear')">é®®æ˜ (C)</span>
                            <span class="sub-label-option" data-label="blurred" onclick="toggleSubLabel('blurred')">ã¼ã‚„ã‘ (B)</span>
                        </div>
                    </div>
                    <div class="sub-label-group">
                        <h4>é¼»ã®è‰²</h4>
                        <div class="sub-label-options">
                            <span class="sub-label-option" data-label="black" onclick="toggleSubLabel('black')">é»’ (K)</span>
                            <span class="sub-label-option" data-label="brown" onclick="toggleSubLabel('brown')">èŒ¶è‰² (R)</span>
                            <span class="sub-label-option" data-label="gray" onclick="toggleSubLabel('gray')">ç°è‰² (G)</span>
                            <span class="sub-label-option" data-label="pink" onclick="toggleSubLabel('pink')">ãƒ”ãƒ³ã‚¯ (P)</span>
                            <span class="sub-label-option" data-label="marble" onclick="toggleSubLabel('marble')">ãƒãƒ¼ãƒ–ãƒ« (M)</span>
                        </div>
                    </div>
                    <div class="sub-label-group">
                        <h4>é¼»ã®å¤§ãã•</h4>
                        <div class="sub-label-options">
                            <span class="sub-label-option" data-label="large" onclick="toggleSubLabel('large')">å¤§ãã„ (L)</span>
                            <span class="sub-label-option" data-label="small" onclick="toggleSubLabel('small')">å°ã•ã„ (Q)</span>
                        </div>
                    </div>
                    <div class="sub-label-group">
                        <h4>æ¯›è‰²</h4>
                        <div class="sub-label-options">
                            <span class="sub-label-option" data-label="light_fur" onclick="toggleSubLabel('light_fur')">æ˜ã‚‹ã„æ¯›è‰² (J)</span>
                            <span class="sub-label-option" data-label="dark_fur" onclick="toggleSubLabel('dark_fur')">æš—ã„æ¯›è‰² (N)</span>
                        </div>
                    </div>
                </div>

                <div class="dataset-split">
                    <h3>ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆåˆ†å‰²</h3>
                    <div class="split-buttons">
                        <button class="split-button" onclick="setDatasetSplit('train')">Train</button>
                        <button class="split-button" onclick="setDatasetSplit('val')">Val</button>
                        <button class="split-button" onclick="setDatasetSplit('test')">Test</button>
                    </div>
                </div>

                <button class="save-button" onclick="saveLabel()">ğŸ’¾ ãƒ©ãƒ™ãƒ«ã‚’ä¿å­˜</button>

                <div class="export-section">
                    <div style="margin-top:10px;">
                        <button class="export-button" onclick="exportCurrentImageDataset()">ã“ã®ç”»åƒã ã‘ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆZIP</button>
                    </div>
                </div>

                <div class="shortcuts">
                    <h4>âŒ¨ï¸ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ</h4>
                    <div class="shortcut-item">
                        <span>é¼»ã‚ã‚Š:</span>
                        <span class="shortcut-key">1</span>
                    </div>
                    <div class="shortcut-item">
                        <span>é¼»ãªã—:</span>
                        <span class="shortcut-key">2</span>
                    </div>
                    <div class="shortcut-item">
                        <span>æ­£é¢:</span>
                        <span class="shortcut-key">F</span>
                    </div>
                    <div class="shortcut-item">
                        <span>æ¨ªå‘ã:</span>
                        <span class="shortcut-key">S</span>
                    </div>
                    <div class="shortcut-item">
                        <span>æ–œã‚:</span>
                        <span class="shortcut-key">T</span>
                    </div>
                    <div class="shortcut-item">
                        <span>æ¿¡ã‚Œã¦ã„ã‚‹:</span>
                        <span class="shortcut-key">W</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ä¹¾ã„ã¦ã„ã‚‹:</span>
                        <span class="shortcut-key">D</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ã¼ã‚„ã‘ã¦ã„ã‚‹:</span>
                        <span class="shortcut-key">B</span>
                    </div>
                    <div class="shortcut-item">
                        <span>é»’:</span>
                        <span class="shortcut-key">K</span>
                    </div>
                    <div class="shortcut-item">
                        <span>èŒ¶è‰²:</span>
                        <span class="shortcut-key">R</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ãƒ”ãƒ³ã‚¯:</span>
                        <span class="shortcut-key">P</span>
                    </div>
                    <div class="shortcut-item">
                        <span>å‰ã®ç”»åƒ:</span>
                        <span class="shortcut-key">â†</span>
                    </div>
                    <div class="shortcut-item">
                        <span>æ¬¡ã®ç”»åƒ:</span>
                        <span class="shortcut-key">â†’</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ä¿å­˜:</span>
                        <span class="shortcut-key">Enter</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ã“ã®ç”»åƒã ã‘ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆZIPã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        async function exportCurrentImageDataset() {
            if (!images || images.length === 0) {
                alert('ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            const image = images[currentImageIndex];
            if (!image || !image.id) {
                alert('ç”»åƒæƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“');
                return;
            }
            const btn = document.querySelector('.export-button[onclick="exportCurrentImageDataset()"]');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­...';
            }
            try {
                const res = await fetch(`/api/export_single/${image.id}`);
                if (!res.ok) throw new Error('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                const blob = await res.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${image.filename.replace(/\.[^.]+$/, '')}_dataset.zip`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                }, 100);
            } catch (e) {
                alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'ã“ã®ç”»åƒã ã‘ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆZIP';
                }
            }
        }
        // --- å…ƒç”»åƒã‚µã‚¤ã‚ºç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« ---
        let originalModal = null;
        let originalModalContent = null;
        let originalModalImg = null;
        let originalModalCanvas = null;
        let originalModalCtx = null;
        let originalModalBbox = null;
        let originalModalEditing = false;
        let originalModalStartX = 0, originalModalStartY = 0;
        let originalModalIsDrawing = false;
        let originalModalIsMoving = false;
        let originalModalMoveOffsetX = 0, originalModalMoveOffsetY = 0;
        let originalModalOriginalBbox = null;
        let originalModalResizeCorner = null;
        let originalModalIsResizing = false;

        function setupOriginalModalEvents() {
            if (!originalModalCanvas) return;
            // æ—¢å­˜ã‚¤ãƒ™ãƒ³ãƒˆã‚’é™¤å»
            originalModalCanvas.onmousedown = null;
            originalModalCanvas.onmousemove = null;
            originalModalCanvas.onmouseup = null;
            // bboxå–å¾—
            let bbox = originalModalBbox;
            // è§’ãƒãƒ³ãƒ‰ãƒ«åˆ¤å®š
            function getCornerHandle(x, y, bbox, handleSize = 10) {
                if (!bbox) return null;
                let { x_min, y_min, x_max, y_max } = bbox;
                if (x_min > x_max) [x_min, x_max] = [x_max, x_min];
                if (y_min > y_max) [y_min, y_max] = [y_max, y_min];
                const corners = [
                    { name: 'tl', x: x_min, y: y_min },
                    { name: 'tr', x: x_max, y: y_min },
                    { name: 'bl', x: x_min, y: y_max },
                    { name: 'br', x: x_max, y: y_max }
                ];
                for (const corner of corners) {
                    if (Math.abs(x - corner.x) <= handleSize && Math.abs(y - corner.y) <= handleSize) {
                        return corner.name;
                    }
                }
                return null;
            }
            originalModalCanvas.addEventListener('mousedown', function(e) {
                const rect = originalModalCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (originalModalCanvas.width / rect.width);
                const y = (e.clientY - rect.top) * (originalModalCanvas.height / rect.height);
                // è§’ãƒãƒ³ãƒ‰ãƒ«åˆ¤å®š
                const corner = bbox ? getCornerHandle(x, y, bbox) : null;
                if (bbox && corner) {
                    // ãƒªã‚µã‚¤ã‚º
                    originalModalIsResizing = true;
                    originalModalResizeCorner = corner;
                    originalModalOriginalBbox = { ...bbox };
                } else if (bbox && x >= bbox.x_min && x <= bbox.x_max && y >= bbox.y_min && y <= bbox.y_max) {
                    // ç§»å‹•
                    originalModalIsMoving = true;
                    originalModalOriginalBbox = { ...bbox };
                    originalModalMoveOffsetX = x - bbox.x_min;
                    originalModalMoveOffsetY = y - bbox.y_min;
                } else {
                    // æ–°è¦ä½œæˆ
                    originalModalIsDrawing = true;
                    bbox = { x_min: x, y_min: y, x_max: x, y_max: y };
                }
                originalModalBbox = bbox;
            });
            originalModalCanvas.addEventListener('mousemove', function(e) {
                const rect = originalModalCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (originalModalCanvas.width / rect.width);
                const y = (e.clientY - rect.top) * (originalModalCanvas.height / rect.height);
                if (originalModalIsDrawing) {
                    bbox.x_max = x;
                    bbox.y_max = y;
                    drawOriginalModalBbox();
                } else if (originalModalIsMoving) {
                    const w = originalModalOriginalBbox.x_max - originalModalOriginalBbox.x_min;
                    const h = originalModalOriginalBbox.y_max - originalModalOriginalBbox.y_min;
                    bbox.x_min = x - originalModalMoveOffsetX;
                    bbox.y_min = y - originalModalMoveOffsetY;
                    bbox.x_max = bbox.x_min + w;
                    bbox.y_max = bbox.y_min + h;
                    drawOriginalModalBbox();
                } else if (originalModalIsResizing) {
                    let { x_min, y_min, x_max, y_max } = originalModalOriginalBbox;
                    switch (originalModalResizeCorner) {
                        case 'tl':
                            bbox.x_min = x;
                            bbox.y_min = y;
                            break;
                        case 'tr':
                            bbox.x_max = x;
                            bbox.y_min = y;
                            break;
                        case 'bl':
                            bbox.x_min = x;
                            bbox.y_max = y;
                            break;
                        case 'br':
                            bbox.x_max = x;
                            bbox.y_max = y;
                            break;
                    }
                    drawOriginalModalBbox();
                }
                originalModalBbox = bbox;
            });
            originalModalCanvas.addEventListener('mouseup', function(e) {
                originalModalIsDrawing = false;
                originalModalIsMoving = false;
                originalModalIsResizing = false;
            });
        }

        function drawOriginalModalBbox() {
            if (!originalModalCanvas || !originalModalBbox) return;
            const ctx = originalModalCanvas.getContext('2d');
            ctx.clearRect(0, 0, originalModalCanvas.width, originalModalCanvas.height);
            const { x_min, y_min, x_max, y_max } = originalModalBbox;
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            ctx.strokeRect(x_min, y_min, x_max - x_min, y_max - y_min);
            // è§’ãƒãƒ³ãƒ‰ãƒ«
            ctx.fillStyle = 'deepskyblue';
            const handleSize = 8;
            [
                [x_min, y_min], [x_max, y_min], [x_min, y_max], [x_max, y_max]
            ].forEach(([cx, cy]) => {
                ctx.fillRect(cx - handleSize/2, cy - handleSize/2, handleSize, handleSize);
            });
        }

        function openOriginalModal(imgUrl, bbox) {
            if (!originalModal) {
                originalModal = document.getElementById('originalModal');
                originalModalContent = document.getElementById('originalModalContent');
            }
            originalModalContent.innerHTML = '';
            originalModalImg = new window.Image();
            originalModalImg.src = imgUrl;
            originalModalImg.onload = function() {
                // å…ƒç”»åƒã‚µã‚¤ã‚ºã§canvasç”Ÿæˆ
                originalModalCanvas = document.createElement('canvas');
                originalModalCanvas.width = originalModalImg.naturalWidth;
                originalModalCanvas.height = originalModalImg.naturalHeight;
                originalModalCanvas.style.width = originalModalImg.naturalWidth + 'px';
                originalModalCanvas.style.height = originalModalImg.naturalHeight + 'px';
                originalModalCanvas.style.position = 'absolute';
                originalModalCanvas.style.left = '0';
                originalModalCanvas.style.top = '0';
                originalModalCanvas.style.zIndex = '2';
                // ãƒ©ãƒƒãƒ‘ãƒ¼
                const wrapper = document.createElement('div');
                wrapper.style.position = 'relative';
                wrapper.style.display = 'inline-block';
                wrapper.appendChild(originalModalImg);
                wrapper.appendChild(originalModalCanvas);
                originalModalContent.appendChild(wrapper);
                // bboxåˆæœŸå€¤
                if (bbox && typeof bbox === 'object' && 'x_min' in bbox) {
                    originalModalBbox = { ...bbox };
                } else {
                    originalModalBbox = null;
                }
                drawOriginalModalBbox();
                setupOriginalModalEvents();
            };
            originalModal.style.display = 'flex';
        }

        function closeOriginalModal() {
            if (originalModal) originalModal.style.display = 'none';
        }

        function saveOriginalModalBbox() {
            // ç·¨é›†çµæœã‚’åæ˜ 
            if (originalModalBbox) {
                // ç¾åœ¨è¡¨ç¤ºä¸­ç”»åƒã®bboxã«ä¸Šæ›¸ã
                if (images[currentImageIndex]) {
                    images[currentImageIndex].bbox = { ...originalModalBbox };
                }
                // window.currentBboxã«ã‚‚åæ˜ ï¼ˆä¿å­˜æ™‚ã«æ­£ã—ã„å€¤ãŒé€ä¿¡ã•ã‚Œã‚‹ã‚ˆã†ã«ï¼‰
                window.currentBbox = { ...originalModalBbox };
                drawBboxOnCanvas(originalModalBbox, document.getElementById('bboxCanvas'));
            }
            closeOriginalModal();
        }

        window.addEventListener('DOMContentLoaded', function() {
            document.getElementById('openOriginalModalBtn').onclick = function() {
                // ç¾åœ¨ç”»åƒã®URLã¨bbox
                const img = document.querySelector('#imageCanvasWrapper img');
                const bbox = images[currentImageIndex] && images[currentImageIndex].bbox ? { ...images[currentImageIndex].bbox } : null;
                if (img) {
                    openOriginalModal(img.src, bbox);
                }
            };
            document.getElementById('closeOriginalModalBtn').onclick = closeOriginalModal;
            document.getElementById('saveOriginalModalBtn').onclick = saveOriginalModalBbox;
        });
        let images = [];
        let currentImageIndex = 0;
        let currentMainLabel = null;
        let currentSubLabels = [];
        let currentDatasetSplit = null;

        // åˆæœŸåŒ–
        async function init() {
            try {
                const response = await fetch('/api/images');
                images = await response.json();
                
                if (images.length === 0) {
                    document.getElementById('imageContainer').innerHTML = 
                        '<div class="no-images">imagesãƒ•ã‚©ãƒ«ãƒ€ã«ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é…ç½®ã—ã¦ãã ã•ã„</div>';
                    return;
                }
                
                document.getElementById('totalImages').textContent = images.length;
                
                // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ç”»åƒIDã‚’å–å¾—
                const urlParams = new URLSearchParams(window.location.search);
                const imageId = urlParams.get('imageId');
                
                if (imageId) {
                    // æŒ‡å®šã•ã‚ŒãŸç”»åƒIDã«å¯¾å¿œã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¤œç´¢
                    const targetIndex = images.findIndex(img => img.id == imageId);
                    if (targetIndex !== -1) {
                        loadImage(targetIndex);
                        // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ï¼ˆå±¥æ­´ã‚’æ±šã•ãªã„ãŸã‚ï¼‰
                        window.history.replaceState({}, document.title, window.location.pathname);
                    } else {
                        loadImage(0);
                    }
                } else {
                    loadImage(0);
                }
            } catch (error) {
                console.error('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
                document.getElementById('imageContainer').innerHTML = 
                    '<div class="no-images">ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
            }
        }

        // ç”»åƒã‚’èª­ã¿è¾¼ã¿
        function loadImage(index) {
            if (index < 0 || index >= images.length) return;
            currentImageIndex = index;
            const image = images[index];
            // ç”»åƒã¨canvasã‚’ãƒ©ãƒƒãƒ‘ãƒ¼å†…ã«æŒ¿å…¥
            const wrapper = document.getElementById('imageCanvasWrapper');
            const cropWrapper = document.getElementById('croppedBoxWrapper');
            const croppedCanvas = document.getElementById('croppedBoxCanvas');
            if (wrapper) {
                const loadingDiv = document.querySelector('#imageContainer .loading');
                if (loadingDiv) loadingDiv.style.display = 'none';
                wrapper.innerHTML = '';
                const img = document.createElement('img');
                img.src = `/images/${image.filename}`;
                img.alt = image.filename;
                img.className = 'image-display';
                img.style.display = 'block';
                img.onload = function() {
                    // å…ƒç”»åƒã‚µã‚¤ã‚ºã§canvasç”Ÿæˆ
                    let canvas = document.createElement('canvas');
                    canvas.id = 'bboxCanvas';
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    canvas.style.position = 'absolute';
                    canvas.style.left = '0';
                    canvas.style.top = '0';
                    canvas.style.zIndex = '2';
                    // è¡¨ç¤ºã‚µã‚¤ã‚ºã‚’imgã¨åˆã‚ã›ã‚‹
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    let showCropped = false;
                    let bboxObj = null;
                    if (image.main_label === 'nose') {
                        canvas.style.display = 'block';
                        bboxObj = image.bbox ? (typeof image.bbox === 'string' ? JSON.parse(image.bbox) : image.bbox) : null;
                        drawBboxOnCanvas(bboxObj, canvas);
                        window.currentBbox = bboxObj;
                        images[currentImageIndex].bbox = bboxObj;
                        // bboxé ˜åŸŸãã‚ŠæŠœãè¡¨ç¤º
                        if (bboxObj && bboxObj.x_min != null && bboxObj.y_min != null && bboxObj.x_max != null && bboxObj.y_max != null) {
                            showCropped = true;
                            // å…ƒç”»åƒã®naturalã‚µã‚¤ã‚ºåŸºæº–ã§åˆ‡ã‚ŠæŠœãã€2å€æ‹¡å¤§è¡¨ç¤º
                            const cropW = bboxObj.x_max - bboxObj.x_min;
                            const cropH = bboxObj.y_max - bboxObj.y_min;
                            const scale = 2.0;
                            croppedCanvas.width = cropW * scale;
                            croppedCanvas.height = cropH * scale;
                            croppedCanvas.style.width = (cropW * scale) + 'px';
                            croppedCanvas.style.height = (cropH * scale) + 'px';
                            const ctx = croppedCanvas.getContext('2d');
                            ctx.clearRect(0, 0, cropW * scale, cropH * scale);
                            ctx.drawImage(
                                img,
                                bboxObj.x_min,
                                bboxObj.y_min,
                                cropW,
                                cropH,
                                0, 0, cropW * scale, cropH * scale
                            );
                        }
                    } else {
                        canvas.style.display = 'none';
                        window.currentBbox = null;
                        images[currentImageIndex].bbox = null;
                    }
                    // ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’position:relativeã§img/canvasé‡ã­ã‚‹
                    wrapper.style.position = 'relative';
                    wrapper.style.display = 'inline-block';
                    wrapper.appendChild(img);
                    wrapper.appendChild(canvas);
                    // canvasä¸Šã§bboxç·¨é›†ã§ãã‚‹ã‚ˆã†ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰
                    setupBboxCanvasEvents(canvas, img);
                    // ãã‚ŠæŠœãé ˜åŸŸã®è¡¨ç¤ºåˆ‡æ›¿
                    if (cropWrapper) cropWrapper.style.display = showCropped ? 'block' : 'none';
                };
            }
        // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æç”»é–¢æ•°
    window.drawBboxOnCanvas = function drawBboxOnCanvas(bboxJson, canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!bboxJson) return;
            let bbox;
            try {
                bbox = typeof bboxJson === 'string' ? JSON.parse(bboxJson) : bboxJson;
            } catch (e) { return; }
            if (bbox && bbox.x_min != null) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.strokeRect(
                    bbox.x_min,
                    bbox.y_min,
                    bbox.x_max - bbox.x_min,
                    bbox.y_max - bbox.y_min
                );
                // è§’ãƒãƒ³ãƒ‰ãƒ«æç”»
                const handleSize = 8;
                const corners = [
                    [bbox.x_min, bbox.y_min],
                    [bbox.x_max, bbox.y_min],
                    [bbox.x_min, bbox.y_max],
                    [bbox.x_max, bbox.y_max]
                ];
                ctx.fillStyle = '#00bfff';
                for (const [cx, cy] of corners) {
                    ctx.fillRect(
                        cx - handleSize/2,
                        cy - handleSize/2,
                        handleSize,
                        handleSize
                    );
                }
            }
        }

        // bboxæç”»ãƒ»ç·¨é›†ç”¨ã®ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ‰ãƒ©ãƒƒã‚°ã§æ–°è¦ä½œæˆ/ç·¨é›†ï¼‰
        function setupBboxCanvasEvents(canvas, img) {
            // æ—¢å­˜ã‚¤ãƒ™ãƒ³ãƒˆã‚’é™¤å»
            canvas.onmousedown = null;
            canvas.onmousemove = null;
            canvas.onmouseup = null;
            let isDrawing = false;
            let isMoving = false;
            let isResizing = false;
            let startX = 0, startY = 0;
            let moveOffsetX = 0, moveOffsetY = 0;
            let currentBbox = window.currentBbox || null;
            let originalBbox = null;
            let resizeCorner = null;

            // bboxå†…åˆ¤å®šé–¢æ•°
            function isInsideBbox(x, y, bbox) {
                if (!bbox) return false;
                let { x_min, y_min, x_max, y_max } = bbox;
                if (x_min > x_max) [x_min, x_max] = [x_max, x_min];
                if (y_min > y_max) [y_min, y_max] = [y_max, y_min];
                return x >= x_min && x <= x_max && y >= y_min && y <= y_max;
            }

            // è§’ãƒãƒ³ãƒ‰ãƒ«åˆ¤å®š
            function getCornerHandle(x, y, bbox, handleSize = 10) {
                if (!bbox) return null;
                let { x_min, y_min, x_max, y_max } = bbox;
                if (x_min > x_max) [x_min, x_max] = [x_max, x_min];
                if (y_min > y_max) [y_min, y_max] = [y_max, y_min];
                const corners = [
                    { name: 'tl', x: x_min, y: y_min }, // å·¦ä¸Š
                    { name: 'tr', x: x_max, y: y_min }, // å³ä¸Š
                    { name: 'bl', x: x_min, y: y_max }, // å·¦ä¸‹
                    { name: 'br', x: x_max, y: y_max }  // å³ä¸‹
                ];
                for (const corner of corners) {
                    if (Math.abs(x - corner.x) <= handleSize && Math.abs(y - corner.y) <= handleSize) {
                        return corner.name;
                    }
                }
                return null;
            }

            canvas.addEventListener('mousedown', function(e) {
                if (currentMainLabel !== 'nose') return;
                const rect = canvas.getBoundingClientRect();
                startX = (e.clientX - rect.left) * (canvas.width / rect.width);
                startY = (e.clientY - rect.top) * (canvas.height / rect.height);
                // æ—¢å­˜bboxå–å¾—
                let bbox = null;
                if (images[currentImageIndex] && images[currentImageIndex].bbox) {
                    try {
                        bbox = typeof images[currentImageIndex].bbox === 'string' ? JSON.parse(images[currentImageIndex].bbox) : images[currentImageIndex].bbox;
                    } catch {}
                }
                // è§’ãƒãƒ³ãƒ‰ãƒ«åˆ¤å®š
                const corner = bbox ? getCornerHandle(startX, startY, bbox) : null;
                if (bbox && corner) {
                    // ãƒªã‚µã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰
                    isResizing = true;
                    resizeCorner = corner;
                    originalBbox = { ...bbox };
                    currentBbox = { ...bbox };
                } else if (bbox && isInsideBbox(startX, startY, bbox)) {
                    // ç§»å‹•ãƒ¢ãƒ¼ãƒ‰
                    isMoving = true;
                    originalBbox = { ...bbox };
                    moveOffsetX = startX - bbox.x_min;
                    moveOffsetY = startY - bbox.y_min;
                    currentBbox = { ...bbox };
                } else {
                    // æ–°è¦ä½œæˆãƒ¢ãƒ¼ãƒ‰
                    isDrawing = true;
                    currentBbox = { x_min: startX, y_min: startY, x_max: startX, y_max: startY };
                }
            });

            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                if (isDrawing) {
                    // æ­£æ–¹å½¢åŒ–: ãƒ‰ãƒ©ãƒƒã‚°æ–¹å‘ã«å¿œã˜ã¦ä¸€è¾ºã®é•·ã•ã‚’æ±ºå®š
                    const dx = x - startX;
                    const dy = y - startY;
                    const side = Math.min(Math.abs(dx), Math.abs(dy));
                    let x_max, y_max;
                    if (dx >= 0 && dy >= 0) { // å³ä¸‹
                        x_max = startX + side;
                        y_max = startY + side;
                    } else if (dx < 0 && dy < 0) { // å·¦ä¸Š
                        x_max = startX - side;
                        y_max = startY - side;
                    } else if (dx >= 0 && dy < 0) { // å³ä¸Š
                        x_max = startX + side;
                        y_max = startY - side;
                    } else { // å·¦ä¸‹
                        x_max = startX - side;
                        y_max = startY + side;
                    }
                    currentBbox.x_max = x_max;
                    currentBbox.y_max = y_max;
                    drawBboxOnCanvas(currentBbox, canvas);
                } else if (isMoving) {
                    // bboxç§»å‹•
                    const bboxWidth = originalBbox.x_max - originalBbox.x_min;
                    const bboxHeight = originalBbox.y_max - originalBbox.y_min;
                    // æ­£æ–¹å½¢ãªã®ã§ä¸€è¾º
                    const side = Math.min(Math.abs(bboxWidth), Math.abs(bboxHeight));
                    let new_x_min = x - moveOffsetX;
                    let new_y_min = y - moveOffsetY;
                    let new_x_max = new_x_min + side;
                    let new_y_max = new_y_min + side;
                    currentBbox = { x_min: new_x_min, y_min: new_y_min, x_max: new_x_max, y_max: new_y_max };
                    drawBboxOnCanvas(currentBbox, canvas);
                } else if (isResizing) {
                    // ãƒªã‚µã‚¤ã‚º: ã©ã®è§’ã§ã‚‚æ­£æ–¹å½¢ã‚’ç¶­æŒã—ã¤ã¤ã‚ºãƒ¬ãªãå‹•ä½œã•ã›ã‚‹
                    let { x_min, y_min, x_max, y_max } = originalBbox;
                    let new_x_min = x_min, new_y_min = y_min, new_x_max = x_max, new_y_max = y_max;
                    switch (resizeCorner) {
                        case 'tl': {
                            // å·¦ä¸Šã‚’ãƒ‰ãƒ©ãƒƒã‚°
                            const side = Math.max(x_max - x, y_max - y);
                            new_x_min = x_max - side;
                            new_y_min = y_max - side;
                            break;
                        }
                        case 'tr': {
                            // å³ä¸Šã‚’ãƒ‰ãƒ©ãƒƒã‚°
                            const side = Math.max(x - x_min, y_max - y);
                            new_x_max = x_min + side;
                            new_y_min = y_max - side;
                            break;
                        }
                        case 'bl': {
                            // å·¦ä¸‹ã‚’ãƒ‰ãƒ©ãƒƒã‚°
                            const side = Math.max(x_max - x, y - y_min);
                            new_x_min = x_max - side;
                            new_y_max = y_min + side;
                            break;
                        }
                        case 'br': {
                            // å³ä¸‹ã‚’ãƒ‰ãƒ©ãƒƒã‚°
                            const side = Math.max(x - x_min, y - y_min);
                            new_x_max = x_min + side;
                            new_y_max = y_min + side;
                            break;
                        }
                    }
                    currentBbox = { x_min: new_x_min, y_min: new_y_min, x_max: new_x_max, y_max: new_y_max };
                    drawBboxOnCanvas(currentBbox, canvas);
                }
                window.currentBbox = currentBbox;
            });

            canvas.addEventListener('mouseup', function(e) {
                if (isDrawing) {
                    isDrawing = false;
                    // æ–°è¦ä½œæˆæ™‚ã®ã¿æ­£æ–¹å½¢åŒ–
                    let { x_min, y_min, x_max, y_max } = currentBbox;
                    if (x_min > x_max) [x_min, x_max] = [x_max, x_min];
                    if (y_min > y_max) [y_min, y_max] = [y_max, y_min];
                    // æ­£æ–¹å½¢åŒ–
                    const side = Math.min(x_max - x_min, y_max - y_min);
                    x_max = x_min + side;
                    y_max = y_min + side;
                    currentBbox = { x_min, y_min, x_max, y_max };
                    images[currentImageIndex].bbox = currentBbox;
                    drawBboxOnCanvas(currentBbox, canvas);
                } else if (isMoving) {
                    isMoving = false;
                    // ç§»å‹•æ™‚ã¯ãã®ã¾ã¾
                    images[currentImageIndex].bbox = { ...currentBbox };
                    drawBboxOnCanvas(currentBbox, canvas);
                } else if (isResizing) {
                    isResizing = false;
                    // ãƒªã‚µã‚¤ã‚ºæ™‚ã‚‚ãã®ã¾ã¾
                    images[currentImageIndex].bbox = { ...currentBbox };
                    drawBboxOnCanvas(currentBbox, canvas);
                }
                window.currentBbox = currentBbox;
            });

            // é¼»ã‚ã‚Šä»¥å¤–ã®æ™‚ã¯canvaséè¡¨ç¤º
            function updateCanvasVisibility() {
                const image = images[currentImageIndex];
                if (currentMainLabel === 'nose' || (image && image.main_label === 'nose')) {
                    canvas.style.display = 'block';
                } else {
                    canvas.style.display = 'none';
                }
            }
            // ãƒ¡ã‚¤ãƒ³ãƒ©ãƒ™ãƒ«å¤‰æ›´æ™‚ã«canvasè¡¨ç¤ºã‚’åˆ¶å¾¡
            window.setMainLabel = (function(orig){
                return function(label) {
                    orig(label);
                    updateCanvasVisibility();
                }
            })(window.setMainLabel);
            // ç”»åƒåˆ‡æ›¿æ™‚ã«ã‚‚åæ˜ 
            window.loadImage = (function(orig){
                return function(index) {
                    orig(index);
                    updateCanvasVisibility();
                }
            })(window.loadImage);
        }
            
            // ç”»åƒæƒ…å ±è¡¨ç¤º
            document.getElementById('imageInfo').style.display = 'block';
            document.getElementById('fileName').textContent = image.filename;
            document.getElementById('filePath').textContent = image.filepath;
            document.getElementById('currentLabel').textContent = 
                image.main_label || 'æœªè¨­å®š';

            // bboxæƒ…å ±è¡¨ç¤º
            let bboxObj = image.bbox ? (typeof image.bbox === 'string' ? JSON.parse(image.bbox) : image.bbox) : null;
            if (bboxObj && bboxObj.x_min != null) {
                document.getElementById('bboxInfo').textContent = `x_min: ${bboxObj.x_min}, y_min: ${bboxObj.y_min}, x_max: ${bboxObj.x_max}, y_max: ${bboxObj.y_max}`;
            } else {
                document.getElementById('bboxInfo').textContent = '-';
            }
            // is_completedæƒ…å ±è¡¨ç¤º
            let isCompleted = (image.is_completed === 1 || image.is_completed === true || image.is_completed === '1') ? 'âœ”ï¸' : 'âœ—';
            document.getElementById('isCompletedInfo').textContent = isCompleted;
            
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ›´æ–°
            document.getElementById('currentIndex').textContent = index + 1;
            
            // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
            document.getElementById('prevBtn').disabled = index === 0;
            document.getElementById('nextBtn').disabled = index === images.length - 1;
            
            // ç¾åœ¨ã®ãƒ©ãƒ™ãƒ«çŠ¶æ…‹ã‚’å¾©å…ƒ
            currentMainLabel = image.main_label;
            currentSubLabels = image.sub_labels ? JSON.parse(image.sub_labels) : [];
            currentDatasetSplit = image.dataset_split;
            
            updateUI();
        }

        // UIçŠ¶æ…‹ã‚’æ›´æ–°
        function updateUI() {
            // ãƒ¡ã‚¤ãƒ³ãƒ©ãƒ™ãƒ«ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
            document.querySelectorAll('.label-button').forEach(btn => {
                btn.classList.remove('active');
            });
            if (currentMainLabel) {
                const activeBtn = document.querySelector(`.label-button.${currentMainLabel}`);
                if (activeBtn) activeBtn.classList.add('active');
            }
            
            // ã‚µãƒ–ãƒ©ãƒ™ãƒ«ã®çŠ¶æ…‹æ›´æ–°
            document.querySelectorAll('.sub-label-option').forEach(option => {
                option.classList.remove('active');
                const label = option.getAttribute('data-label');
                if (label && currentSubLabels.includes(label)) {
                    option.classList.add('active');
                }
            });
            
            // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆåˆ†å‰²ã®çŠ¶æ…‹æ›´æ–°
            document.querySelectorAll('.split-button').forEach(btn => {
                btn.classList.remove('active');
            });
            if (currentDatasetSplit) {
                const activeBtn = document.querySelector(`.split-button[onclick="setDatasetSplit('${currentDatasetSplit}')"]`);
                if (activeBtn) activeBtn.classList.add('active');
            }
        }

        // ãƒ¡ã‚¤ãƒ³ãƒ©ãƒ™ãƒ«è¨­å®šï¼ˆä»»æ„é¸æŠå¯èƒ½ï¼‰
        function setMainLabel(label) {
            if (currentMainLabel === label) {
                currentMainLabel = null;
            } else {
                currentMainLabel = label;
            }
            updateUI();
        }

        // ã‚µãƒ–ãƒ©ãƒ™ãƒ«åˆ‡ã‚Šæ›¿ãˆï¼ˆã‚«ãƒ†ã‚´ãƒªå†…å˜ä¸€é¸æŠãƒ»ã‚¯ãƒªã‚¢å¯èƒ½ï¼‰
        function toggleSubLabel(label) {
            // ã‚µãƒ–ãƒ©ãƒ™ãƒ«ã®ã‚«ãƒ†ã‚´ãƒªå®šç¾©
            const labelCategories = {
                'front': 'orientation',
                'side': 'orientation', 
                'tilted': 'orientation',
                'clear': 'clarity',
                'blurred': 'clarity',
                'black': 'color',
                'brown': 'color',
                'gray': 'color',
                'pink': 'color',
                'marble': 'color',
                'large': 'nose_size',
                'small': 'nose_size',
                'light_fur': 'fur_color',
                'dark_fur': 'fur_color'
            };
            
            const currentCategory = labelCategories[label];
            
            if (currentCategory) {
                // ç¾åœ¨ã®ãƒ©ãƒ™ãƒ«ãŒæ—¢ã«é¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯å‰Šé™¤ï¼ˆã‚¯ãƒªã‚¢ï¼‰
                const currentIndex = currentSubLabels.indexOf(label);
                if (currentIndex > -1) {
                    currentSubLabels.splice(currentIndex, 1);
                } else {
                    // åŒã˜ã‚«ãƒ†ã‚´ãƒªã®ä»–ã®ãƒ©ãƒ™ãƒ«ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¦ã‹ã‚‰æ–°ã—ã„ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ ï¼ˆå˜ä¸€é¸æŠï¼‰
                    const categoryLabels = Object.keys(labelCategories).filter(
                        key => labelCategories[key] === currentCategory
                    );
                    categoryLabels.forEach(categoryLabel => {
                        const index = currentSubLabels.indexOf(categoryLabel);
                        if (index > -1) {
                            currentSubLabels.splice(index, 1);
                        }
                    });
                    currentSubLabels.push(label);
                }
            }
            
            updateUI();
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆåˆ†å‰²è¨­å®š
        function setDatasetSplit(split) {
            currentDatasetSplit = split;
            updateUI();
        }

        // ãƒ©ãƒ™ãƒ«ä¿å­˜
        async function saveLabel() {
            
            const image = images[currentImageIndex];
            let bbox = window.currentBbox || null;
            const data = {
                image_path: image.filepath,
                main_label: currentMainLabel,
                sub_labels: currentSubLabels,
                dataset_split: currentDatasetSplit,
                bbox: bbox ? JSON.stringify(bbox) : null // ã“ã“ã ã‘æ–‡å­—åˆ—åŒ–
            };
            
            try {
                const response = await fetch('/api/labels', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });
                
                if (response.ok) {
                    // ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                    images[currentImageIndex].main_label = currentMainLabel;
                    images[currentImageIndex].sub_labels = JSON.stringify(currentSubLabels);
                    images[currentImageIndex].dataset_split = currentDatasetSplit;
                    images[currentImageIndex].is_completed = 1;
                    // ç¾åœ¨ã®ãƒ©ãƒ™ãƒ«è¡¨ç¤ºã‚’æ›´æ–°
                    document.getElementById('currentLabel').textContent = currentMainLabel;
                    document.getElementById('isCompletedInfo').textContent = 'âœ”ï¸';
                    // æ¬¡ã®ç”»åƒã«ç§»å‹•
                    if (currentImageIndex < images.length - 1) {
                        nextImage();
                    }
                } else {
                    alert('ãƒ©ãƒ™ãƒ«ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            } catch (error) {
                console.error('ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ©ãƒ™ãƒ«ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        // å‰ã®ç”»åƒ
        function previousImage() {
            if (currentImageIndex > 0) {
                loadImage(currentImageIndex - 1);
            }
        }

        // æ¬¡ã®ç”»åƒ
        function nextImage() {
            if (currentImageIndex < images.length - 1) {
                loadImage(currentImageIndex + 1);
            }
        }



        // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        function exportDataset() {
            window.open('/api/export/dataset', '_blank');
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
        document.addEventListener('keydown', function(event) {
            // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒã‚ã‚‹å ´åˆã¯ç„¡è¦–
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }
            
            switch(event.key) {
                case '1':
                    setMainLabel('nose');
                    break;
                case 'f':
                case 'F':
                    toggleSubLabel('front');
                    break;
                case 's':
                case 'S':
                    toggleSubLabel('side');
                    break;
                case 't':
                case 'T':
                    toggleSubLabel('tilted');
                    break;
                case 'c':
                case 'C':
                    toggleSubLabel('clear');
                    break;
                case 'b':
                case 'B':
                    toggleSubLabel('blurred');
                    break;
                case 'k':
                case 'K':
                    toggleSubLabel('black');
                    break;
                case 'r':
                case 'R':
                    toggleSubLabel('brown');
                    break;
                case 'p':
                case 'P':
                    toggleSubLabel('pink');
                    break;
                case 'g':
                case 'G':
                    toggleSubLabel('gray');
                    break;
                case 'm':
                case 'M':
                    toggleSubLabel('marble');
                    break;
                case 'l':
                case 'L':
                    toggleSubLabel('large');
                    break;
                case 'q':
                case 'Q':
                    toggleSubLabel('small');
                    break;
                case 'j':
                case 'J':
                    toggleSubLabel('light_fur');
                    break;
                case 'n':
                case 'N':
                    toggleSubLabel('dark_fur');
                    break;
                case 'ArrowLeft':
                    previousImage();
                    break;
                case 'ArrowRight':
                    nextImage();
                    break;
                case 'Enter':
                    saveLabel();
                    break;
            }
        });


        async function previewAutoSplit() {
            const trainPercent = parseFloat(document.getElementById('trainPercent').value);
            const valPercent = parseFloat(document.getElementById('valPercent').value);
            const testPercent = parseFloat(document.getElementById('testPercent').value);
            
            const total = trainPercent + valPercent + testPercent;
            if (Math.abs(total - 100) > 0.01) {
                alert(`å‰²åˆã®åˆè¨ˆãŒ100%ã«ãªã‚Šã¾ã›ã‚“: ${total}%`);
                return;
            }
            
            if (trainPercent < 0 || valPercent < 0 || testPercent < 0) {
                alert('å‰²åˆã¯0ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            const requestData = {
                train_percent: trainPercent,
                val_percent: valPercent,
                test_percent: testPercent,
                preview_only: true
            };
            
            const button = document.querySelector('.preview-button');
            const originalText = button.textContent;
            button.textContent = 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­...';
            button.disabled = true;
            
            try {
                const response = await fetch('/api/auto-split', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    displayPreviewResult(result);
                } else {
                    alert(result.error || 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            } catch (error) {
                console.error('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        function displayPreviewResult(result) {
            const previewDiv = document.getElementById('splitPreview');
            
            previewDiv.innerHTML = `
                <h4>ğŸ“Š åˆ†å‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h4>
                <p>ãƒ¡ã‚¤ãƒ³ãƒ©ãƒ™ãƒ«è¨­å®šæ¸ˆã¿ç”»åƒ: <strong>${result.total_images}æš</strong></p>
                <div class="preview-stats">
                    <div class="stat-item">
                        <div class="stat-value">${result.train_count}æš</div>
                        <div class="stat-label">Train (${result.train_percent_actual}%)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${result.val_count}æš</div>
                        <div class="stat-label">Val (${result.val_percent_actual}%)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${result.test_count}æš</div>
                        <div class="stat-label">Test (${result.test_percent_actual}%)</div>
                    </div>
                </div>
                <p style="margin-top: 15px; color: #666; font-size: 14px;">
                    âš ï¸ å®Ÿè¡Œã™ã‚‹ã¨æ—¢å­˜ã®åˆ†å‰²è¨­å®šã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™
                </p>
            `;
            
            previewDiv.style.display = 'block';
            document.getElementById('splitResult').style.display = 'none';
        }
        
        async function executeAutoSplit() {
            const trainPercent = parseFloat(document.getElementById('trainPercent').value);
            const valPercent = parseFloat(document.getElementById('valPercent').value);
            const testPercent = parseFloat(document.getElementById('testPercent').value);
            
            const total = trainPercent + valPercent + testPercent;
            if (Math.abs(total - 100) > 0.01) {
                alert(`å‰²åˆã®åˆè¨ˆãŒ100%ã«ãªã‚Šã¾ã›ã‚“: ${total}%`);
                return;
            }
            
            if (trainPercent < 0 || valPercent < 0 || testPercent < 0) {
                alert('å‰²åˆã¯0ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            const requestData = {
                train_percent: trainPercent,
                val_percent: valPercent,
                test_percent: testPercent,
                overwrite_existing: true
            };
            const confirmMessage = `ãƒ¡ã‚¤ãƒ³ãƒ©ãƒ™ãƒ«è¨­å®šæ¸ˆã¿ã®å…¨ã¦ã®ç”»åƒã‚’ä»¥ä¸‹ã®å‰²åˆã§åˆ†å‰²ã—ã¾ã™:\nTrain: ${trainPercent}%\nVal: ${valPercent}%\nTest: ${testPercent}%\n\næ—¢å­˜ã®åˆ†å‰²è¨­å®šã‚‚ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿ`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            const button = document.querySelector('.auto-split-button');
            const originalText = button.textContent;
            button.textContent = 'åˆ†å‰²ä¸­...';
            button.disabled = true;
            
            try {
                const response = await fetch('/api/auto-split', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    displayExecuteResult(result);
                    
                    if (images.length > 0) {
                        const response = await fetch('/api/images');
                        images = await response.json();
                        loadImage(currentImageIndex);
                    }
                } else {
                    alert(result.error || 'è‡ªå‹•åˆ†å‰²ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            } catch (error) {
                console.error('è‡ªå‹•åˆ†å‰²ã‚¨ãƒ©ãƒ¼:', error);
                alert('è‡ªå‹•åˆ†å‰²ã«å¤±æ•—ã—ã¾ã—ãŸ');
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        function displayExecuteResult(result) {
            const resultDiv = document.getElementById('splitResult');
            
            resultDiv.innerHTML = `
                <h4>âœ… è‡ªå‹•åˆ†å‰²å®Œäº†</h4>
                <p>${result.message}</p>
                <div class="preview-stats">
                    <div class="stat-item">
                        <div class="stat-value">${result.train_count}æš</div>
                        <div class="stat-label">Train (${result.train_percent_actual}%)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${result.val_count}æš</div>
                        <div class="stat-label">Val (${result.val_percent_actual}%)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${result.test_count}æš</div>
                        <div class="stat-label">Test (${result.test_percent_actual}%)</div>
                    </div>
                </div>
                <p style="margin-top: 15px; color: #4CAF50; font-weight: bold;">
                    ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»é¢ã§çµæœã‚’ç¢ºèªã§ãã¾ã™
                </p>
            `;
            
            resultDiv.style.display = 'block';
            document.getElementById('splitPreview').style.display = 'none';
        }

        // åˆæœŸåŒ–å®Ÿè¡Œ
        init();
    </script>
</body>
</html>
